{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { SET_LOCATION } from '../actions/routerActions';\nimport { setFilter } from '../actions/searchFilterActions';\n\nfunction parse(qs) {\n  //쿼리 스트링 값을 객체로 반환함\n  const queryString = qs.substr(1);\n  const chunk = queryString.split('&');\n  return chunk.map(chunk => chunk.split(\"=\")).reduce((result, [key, value]) => _objectSpread(_objectSpread({}, result), {}, {\n    [key]: value\n  }), {});\n}\n\nexport default (store => nextRunner => action => {\n  const type = action.type,\n        payload = action.payload;\n  const result = nextRunner(action);\n\n  if (type === SET_LOCATION) {\n    //주소 동기화 액션에서만 작동\n    const _payload$location = payload.location,\n          pathname = _payload$location.pathname,\n          search = _payload$location.search;\n\n    if (pathname === '/') {\n      //경로가 일치할때만 작동\n      store.dispatch(setFilter(parse(search)));\n    }\n  }\n\n  return result;\n});","map":{"version":3,"sources":["C:/React/coin_traders/src/middlewares/routerEffects.js"],"names":["SET_LOCATION","setFilter","parse","qs","queryString","substr","chunk","split","map","reduce","result","key","value","store","nextRunner","action","type","payload","location","pathname","search","dispatch"],"mappings":";;;;;;AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,SAAT,QAA0B,gCAA1B;;AAEA,SAASC,KAAT,CAAeC,EAAf,EAAkB;AACd;AACA,QAAMC,WAAW,GAAGD,EAAE,CAACE,MAAH,CAAU,CAAV,CAApB;AACA,QAAMC,KAAK,GAAGF,WAAW,CAACG,KAAZ,CAAkB,GAAlB,CAAd;AACA,SAAOD,KAAK,CACXE,GADM,CACDF,KAAD,IAASA,KAAK,CAACC,KAAN,CAAY,GAAZ,CADP,EAENE,MAFM,CAEC,CAACC,MAAD,EAAQ,CAACC,GAAD,EAAKC,KAAL,CAAR,qCACDF,MADC;AACM,KAACC,GAAD,GAAMC;AADZ,IAFD,EAIJ,EAJI,CAAP;AAKH;;AAED,gBAAeC,KAAK,IAAEC,UAAU,IAAEC,MAAM,IAAE;AAAA,QAC/BC,IAD+B,GACbD,MADa,CAC/BC,IAD+B;AAAA,QACzBC,OADyB,GACbF,MADa,CACzBE,OADyB;AAEtC,QAAMP,MAAM,GAAGI,UAAU,CAACC,MAAD,CAAzB;;AACA,MAAGC,IAAI,KAAKhB,YAAZ,EAAyB;AAAE;AAAF,8BACKiB,OAAO,CAACC,QADb;AAAA,UACdC,QADc,qBACdA,QADc;AAAA,UACLC,MADK,qBACLA,MADK;;AAErB,QAAGD,QAAQ,KAAI,GAAf,EAAmB;AAAE;AACjBN,MAAAA,KAAK,CAACQ,QAAN,CAAepB,SAAS,CAACC,KAAK,CAACkB,MAAD,CAAN,CAAxB;AACH;AACJ;;AACD,SAAOV,MAAP;AACH,CAVD","sourcesContent":["import { SET_LOCATION } from '../actions/routerActions';\r\nimport { setFilter } from '../actions/searchFilterActions';\r\n\r\nfunction parse(qs){\r\n    //쿼리 스트링 값을 객체로 반환함\r\n    const queryString = qs.substr(1);\r\n    const chunk = queryString.split('&');\r\n    return chunk\r\n    .map((chunk)=>chunk.split(\"=\"))\r\n    .reduce((result,[key,value])=>({\r\n        ...result,[key]:value\r\n    }),{});\r\n}\r\n\r\nexport default store=>nextRunner=>action=>{\r\n    const {type, payload } = action;\r\n    const result = nextRunner(action);\r\n    if(type === SET_LOCATION){ //주소 동기화 액션에서만 작동\r\n        const {pathname,search} = payload.location;\r\n        if(pathname ==='/'){ //경로가 일치할때만 작동\r\n            store.dispatch(setFilter(parse(search)))\r\n        }\r\n    }\r\n    return result;\r\n}"]},"metadata":{},"sourceType":"module"}